(function(f,x){typeof exports=="object"&&typeof module<"u"?x(exports):typeof define=="function"&&define.amd?define(["exports"],x):(f=typeof globalThis<"u"?globalThis:f||self,x(f["catenary-curve"]={}))})(this,function(f){"use strict";function R(t,e,n,r,u,c){const i=[[e.x,t*Math.cosh((e.x-r)/t)+u]],s=n.x-e.x,o=c-1;for(let l=0;l<o;l++){const y=e.x+s*(l+.5)/o,a=t*Math.cosh((y-r)/t)+u;i.push([y,a])}return i.push([n.x,t*Math.cosh((n.x-r)/t)+u]),i}function d(t){return{type:"line",start:t[0],lines:t.slice(1)}}function T(t,e,n,r){const u=Math.sqrt(n*n-e*e)/t;let c=Math.acosh(u)+1,i=-1,s=0;for(;Math.abs(c-i)>1e-6&&s<r;)i=c,c=c-(Math.sinh(c)-u*c)/(Math.cosh(c)-u),s++;return t/(2*c)}function p(t){let e=t.length-1,n=t[1][0],r=t[1][1];const u=[t[0][0],t[0][1]],c=[];for(let i=2;i<e;i++){const s=t[i][0],o=t[i][1],l=(s+n)*.5,y=(o+r)*.5;c.push([n,r,l,y]),n=s,r=o}return e=t.length,c.push([t[e-2][0],t[e-2][1],t[e-1][0],t[e-1][1]]),{type:"quadraticCurve",start:u,curves:c}}function q(t,e){t.type==="quadraticCurve"?g(t,e):t.type==="line"&&m(t,e)}function m(t,e){e.moveTo(...t.start);for(let n=0;n<t.lines.length;n++)e.lineTo(...t.lines[n])}function g(t,e){e.moveTo(...t.start);for(let n=0;n<t.curves.length;n++)e.quadraticCurveTo(...t.curves[n])}function P(t,e){return{x:t.x-e.x,y:t.y-e.y}}function b(t,e){const n=P(t,e);return Math.sqrt(Math.pow(n.x,2)+Math.pow(n.y,2))}function S(t,e,n,r={}){const u=r.segments||25,c=r.iterationLimit||6,i=t.x>e.x,s=i?e:t,o=i?t:e;if(b(s,o)<n){if(o.x-s.x>.01){const M=o.x-s.x,v=o.y-s.y,h=-T(M,v,n,c),C=(h*Math.log((n+v)/(n-v))-M)*.5,L=h*Math.cosh(C/h),O=s.x-C,j=s.y-L,w=R(h,s,o,O,j,u);return i&&w.reverse(),p(w)}const a=(s.x+o.x)*.5,D=(s.y+o.y+n)*.5;return d([[s.x,s.y],[a,D],[o.x,o.y]])}return d([[s.x,s.y],[o.x,o.y]])}f.drawResult=q,f.drawResultCurve=g,f.drawResultLine=m,f.getCatenaryCurve=S,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});

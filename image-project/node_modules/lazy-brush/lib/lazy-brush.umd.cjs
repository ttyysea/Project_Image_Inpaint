(function(i,s){typeof exports=="object"&&typeof module<"u"?s(exports):typeof define=="function"&&define.amd?define(["exports"],s):(i=typeof globalThis<"u"?globalThis:i||self,s(i["lazy-brush"]={}))})(this,function(i){"use strict";var l=Object.defineProperty;var f=(i,s,h)=>s in i?l(i,s,{enumerable:!0,configurable:!0,writable:!0,value:h}):i[s]=h;var r=(i,s,h)=>(f(i,typeof s!="symbol"?s+"":s,h),h);function s(u){return 1-Math.sqrt(1-Math.pow(u,2))}class h{constructor(t,e){r(this,"x");r(this,"y");this.x=t,this.y=e}update(t){return this.x=t.x,this.y=t.y,this}moveByAngle(t,e,a){const n=t+Math.PI/2;return a?(this.x=this.x+Math.sin(n)*e*s(1-a),this.y=this.y-Math.cos(n)*e*s(1-a)):(this.x=this.x+Math.sin(n)*e,this.y=this.y-Math.cos(n)*e),this}equalsTo(t){return this.x===t.x&&this.y===t.y}getDifferenceTo(t){return new h(this.x-t.x,this.y-t.y)}getDistanceTo(t){const e=this.getDifferenceTo(t);return Math.sqrt(Math.pow(e.x,2)+Math.pow(e.y,2))}getAngleTo(t){const e=this.getDifferenceTo(t);return Math.atan2(e.y,e.x)}toObject(){return{x:this.x,y:this.y}}}const d=30;class o{constructor(t={}){r(this,"_isEnabled");r(this,"_hasMoved");r(this,"radius");r(this,"pointer");r(this,"brush");r(this,"angle");r(this,"distance");const e=t.initialPoint||{x:0,y:0};this.radius=t.radius||d,this._isEnabled=t.enabled!==!1,this.pointer=new h(e.x,e.y),this.brush=new h(e.x,e.y),this.angle=0,this.distance=0,this._hasMoved=!1}enable(){this._isEnabled=!0}disable(){this._isEnabled=!1}isEnabled(){return this._isEnabled}setRadius(t){this.radius=t}getRadius(){return this.radius}getBrushCoordinates(){return this.brush.toObject()}getPointerCoordinates(){return this.pointer.toObject()}getBrush(){return this.brush}getPointer(){return this.pointer}getAngle(){return this.angle}getDistance(){return this.distance}brushHasMoved(){return this._hasMoved}update(t,e={}){if(this._hasMoved=!1,this.pointer.equalsTo(t)&&!e.both&&!e.friction)return!1;if(this.pointer.update(t),e.both)return this._hasMoved=!0,this.brush.update(t),!0;if(this._isEnabled){this.distance=this.pointer.getDistanceTo(this.brush),this.angle=this.pointer.getAngleTo(this.brush);const a=Math.round((this.distance-this.radius)*10)/10>0,n=e.friction&&e.friction<1&&e.friction>0?e.friction:void 0;a&&(this.brush.moveByAngle(this.angle,this.distance-this.radius,n),this._hasMoved=!0)}else this.distance=0,this.angle=0,this.brush.update(t),this._hasMoved=!0;return!0}}i.LazyBrush=o,i.LazyPoint=h,Object.defineProperty(i,Symbol.toStringTag,{value:"Module"})});
